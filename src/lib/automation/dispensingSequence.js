/**
 * Automated Dispensing Sequence - Generate optimal pad dispensing order and G-code
 */

export class DispensingSequencer {
  constructor() {
    this.safeHeight = 5; // mm above PCB
    this.travelSpeed = 3000; // mm/min
    this.dispensingSpeed = 600; // mm/min
  }

  /**
   * Calculate nearest neighbor path from reference point through all pads
   * @param {Object} referencePoint - Starting point {x, y}
   * @param {Array} pads - Array of pad objects with x, y coordinates
   * @returns {Array} Ordered array of pads for optimal dispensing sequence
   */
  calculateOptimalSequence(referencePoint, pads) {
    if (!pads || pads.length === 0) return [];
    
    const unvisited = [...pads];
    const sequence = [];
    let currentPoint = referencePoint;

    while (unvisited.length > 0) {
      // Find nearest unvisited pad
      let nearestIndex = 0;
      let minDistance = this.calculateDistance(currentPoint, unvisited[0]);

      for (let i = 1; i < unvisited.length; i++) {
        const distance = this.calculateDistance(currentPoint, unvisited[i]);
        if (distance < minDistance) {
          minDistance = distance;
          nearestIndex = i;
        }
      }

      // Add nearest pad to sequence and remove from unvisited
      const nearestPad = unvisited.splice(nearestIndex, 1)[0];
      sequence.push({
        ...nearestPad,
        distanceFromPrevious: minDistance,
        sequenceOrder: sequence.length + 1
      });
      
      currentPoint = nearestPad;
    }

    return sequence;
  }

  /**
   * Generate complete G-code for automated dispensing sequence
   * @param {Object} referencePoint - Starting point
   * @param {Array} pads - Ordered pad sequence
   * @param {Object} settings - Dispensing settings
   * @returns {String} Complete G-code for dispensing job
   */
  generateDispensingGCode(referencePoint, pads, settings = {}) {
    const {
      safeHeight = this.safeHeight,
      travelSpeed = this.travelSpeed,
      dispensingSpeed = this.dispensingSpeed,
      pressureSettings = {},
      speedSettings = {}
    } = settings;

    let gcode = [];
    
    // Header and initialization
    gcode.push('; Automated Solder Paste Dispensing Job');
    gcode.push('; Generated by PCB Paste Dispenser');
    gcode.push(`; Total pads: ${pads.length}`);
    gcode.push(`; Reference point: X${referencePoint.x.toFixed(3)} Y${referencePoint.y.toFixed(3)}`);
    gcode.push('');
    gcode.push('G21 ; Set units to millimeters');
    gcode.push('G90 ; Absolute positioning');
    gcode.push('G28 ; Home all axes');
    gcode.push(`G1 Z${safeHeight} F${travelSpeed} ; Move to safe height`);
    gcode.push('');

    // Move to reference point
    gcode.push('; Move to reference point');
    gcode.push(`G1 X${referencePoint.x.toFixed(3)} Y${referencePoint.y.toFixed(3)} F${travelSpeed}`);
    gcode.push('G4 P500 ; Pause 500ms');
    gcode.push('');

    // Dispense on each pad in sequence
    pads.forEach((pad, index) => {
      gcode.push(`; Pad ${index + 1}/${pads.length} - ID: ${pad.id || 'Unknown'}`);
      gcode.push(`; Distance from previous: ${pad.distanceFromPrevious?.toFixed(2) || 0}mm`);
      
      // Travel to pad position (safe height)
      gcode.push(`G1 X${pad.x.toFixed(3)} Y${pad.y.toFixed(3)} Z${safeHeight} F${travelSpeed}`);
      
      // Lower to dispensing height
      gcode.push(`G1 Z0.1 F${dispensingSpeed} ; Lower to dispensing height`);
      
      // Apply pressure and dispense
      const pressure = this.calculatePadPressure(pad, pressureSettings);
      const dwellTime = this.calculateDwellTime(pad, pressureSettings);
      
      gcode.push(`M42 P4 S${pressure} ; Set dispensing pressure`);
      gcode.push(`G4 P${dwellTime} ; Dispense for ${dwellTime}ms`);
      gcode.push('M42 P4 S0 ; Stop dispensing');
      
      // Lift to safe height
      gcode.push(`G1 Z${safeHeight} F${travelSpeed} ; Lift to safe height`);
      gcode.push('');
    });

    // Return to reference point and finish
    gcode.push('; Return to reference point');
    gcode.push(`G1 X${referencePoint.x.toFixed(3)} Y${referencePoint.y.toFixed(3)} F${travelSpeed}`);
    gcode.push('G28 ; Home all axes');
    gcode.push('M84 ; Disable steppers');
    gcode.push('; End of dispensing job');

    return gcode.join('\n');
  }

  /**
   * Calculate distance between two points
   */
  calculateDistance(point1, point2) {
    const dx = point2.x - point1.x;
    const dy = point2.y - point1.y;
    return Math.sqrt(dx * dx + dy * dy);
  }

  /**
   * Calculate total dispensing job statistics
   */
  calculateJobStatistics(referencePoint, sequence) {
    let totalDistance = 0;
    let totalTime = 0; // seconds
    let currentPoint = referencePoint;

    sequence.forEach(pad => {
      const distance = this.calculateDistance(currentPoint, pad);
      totalDistance += distance;
      
      // Travel time + dispensing time
      const travelTime = (distance / this.travelSpeed) * 60; // convert to seconds
      const dispensingTime = 2; // estimated 2 seconds per pad
      totalTime += travelTime + dispensingTime;
      
      currentPoint = pad;
    });

    return {
      totalPads: sequence.length,
      totalDistance: totalDistance.toFixed(2),
      estimatedTime: Math.ceil(totalTime / 60), // minutes
      averageDistance: (totalDistance / sequence.length).toFixed(2)
    };
  }

  /**
   * Calculate pressure for specific pad based on size
   */
  calculatePadPressure(pad, pressureSettings) {
    const area = (pad.width || 1) * (pad.height || 1);
    const basePressure = pressureSettings.customPressure || 25;
    
    // Adjust pressure based on pad area
    if (area < 0.5) return Math.max(15, basePressure - 5);
    if (area > 2.0) return Math.min(40, basePressure + 5);
    return basePressure;
  }

  /**
   * Calculate dwell time for specific pad
   */
  calculateDwellTime(pad, pressureSettings) {
    const area = (pad.width || 1) * (pad.height || 1);
    const baseDwell = pressureSettings.customDwellTime || 120;
    
    // Adjust dwell time based on pad area
    if (area < 0.5) return Math.max(80, baseDwell - 20);
    if (area > 2.0) return Math.min(200, baseDwell + 30);
    return baseDwell;
  }
}